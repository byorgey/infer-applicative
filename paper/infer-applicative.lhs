% -*- mode: LaTeX; compile-command: "./build.sh" -*-
\documentclass[sigplan,screen]{acmart}

%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmlicensed}
\copyrightyear{2024}
\acmYear{2024}
\acmDOI{XXXXXXX.XXXXXXX}

%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[ICFP '25]{The International Conference on Functional
  Programming}{September 10--12, 2025}{City, Country}
%%
%%  Uncomment \acmBooktitle if the title of the proceedings is different
%%  from ``Proceedings of ...''!
%%
%%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%%  June 03--05, 2018, Woodstock, NY}
\acmISBN{978-1-4503-XXXX-X/18/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%

\citestyle{acmauthoryear}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\let\Bbbk\undefined
%include polycode.fmt

%format forall = "\forall"
%format erase(t) = "\lfloor" t "\rfloor"
%format A = "\square\!"
%format <$> = "\mathbin{\langle \$ \rangle}"
%format <*> = "\mathbin{\langle * \rangle}"
%format * = "\mathbin{\times}"
%format s = "\sigma"
%format t = "\tau"
%format << = "\vartriangleleft"

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{amsmath,amssymb}
\usepackage{amsthm}
\usepackage{supertabular}
\usepackage{ifthen}
\usepackage{prettyref}

\input{ott/applicative_defns.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\term}[1]{\emph{#1}}

%% prettyref stuff -------------------------------------------

\newrefformat{fig}{Figure~\ref{#1}}
\newrefformat{sec}{section~\ref{#1}}
\newrefformat{eq}{equation~\eqref{#1}}
\newrefformat{prob}{Problem~\ref{#1}}
\newrefformat{tab}{Table~\ref{#1}}
\newrefformat{thm}{Theorem~\ref{#1}}
\newrefformat{lem}{Lemma~\ref{#1}}
\newrefformat{claim}{Claim~\ref{#1}}
\newrefformat{obs}{Observation~\ref{#1}}
\newrefformat{prop}{Proposition~\ref{#1}}
\newrefformat{defn}{Definition~\ref{#1}}
\newrefformat{cor}{Corollary~\ref{#1}}
\providecommand{\pref}{}
\renewcommand{\pref}[1]{\prettyref{#1}}

% \Pref is just like \pref but it uppercases the first letter; for use
% at the beginning of a sentence.
\providecommand{\Pref}{}
\renewcommand{\Pref}[1]{%
  \expandafter\ifx\csname r@@#1\endcsname\relax {\scriptsize[ref]}
    \else
    \edef\reftext{\prettyref{#1}}\expandafter\MakeUppercase\reftext
    \fi
}

%% theorems --------------------------------------------------

\newtheorem{thm}{Theorem}[section]
\newtheorem{prop}[thm]{Proposition}
\newtheorem{lem}[thm]{Lemma}
\newtheorem{claim}[thm]{Claim}
\newtheorem{cor}[thm]{Corollary}

\theoremstyle{definition}
\newtheorem{defn}[thm]{Definition}
\newtheorem{obs}{Observation}
\newtheorem{prob}{Problem}

\theoremstyle{remark}
\newtheorem*{rem}{Remark}
\newtheorem*{ex}{Example}
\newtheorem*{nota}{Notation}

\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{Idiomatic Inference}

\author{Brent A. Yorgey}
\email{yorgey@@hendrix.edu}
\orcid{0009-0005-0135-6134}
\affiliation{%
  \institution{Hendrix College}
  \city{Conway}
  \state{Arkansas}
  \country{USA}
}

\begin{abstract}
  McBride and Paterson's \emph{idioms}, or \emph{applicative
    functors}, are a well-known abstraction defining function
  application in some ambient effectful context.  It would be useful,
  especially in the context of designing domain-specific languages, to
  \emph{infer} such ``idiomatic'' application, allowing the programmer
  to use plain function application syntax.  We show that this is
  possible in a strong sense, by presenting a formally-verified type
  inference algorithm that can automatically infer uses of an
  applicative functor and insert appropriate coercions.  We also prove
  that this cannot lead to any ambiguity: in cases where there are
  multiple valid type-correct ways to insert coercions, the
  applicative functor laws guarantee that there is no observable
  difference.  We also extend our results to selective functors, but
  demonstrate via examples that inference for monads is inherently
  ambiguous.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
 <concept>
  <concept_id>00000000.0000000.0000000</concept_id>
  <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
  <concept_significance>500</concept_significance>
 </concept>
 <concept>
  <concept_id>00000000.00000000.00000000</concept_id>
  <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
  <concept_significance>300</concept_significance>
 </concept>
 <concept>
  <concept_id>00000000.00000000.00000000</concept_id>
  <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
 <concept>
  <concept_id>00000000.00000000.00000000</concept_id>
  <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
  <concept_significance>100</concept_significance>
 </concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Do Not Use This Code~Generate the Correct Terms for Your Paper}
\ccsdesc[300]{Do Not Use This Code~Generate the Correct Terms for Your Paper}
\ccsdesc{Do Not Use This Code~Generate the Correct Terms for Your Paper}
\ccsdesc[100]{Do Not Use This Code~Generate the Correct Terms for Your Paper}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{applicative, functor, inference, Agda}
%% A "teaser" image appears between the author and affiliation
%% information and the body of the document, and typically spans the
%% page.
% \begin{teaserfigure}
%   \includegraphics[width=\textwidth]{sampleteaser}
%   \caption{Seattle Mariners at Spring Training, 2010.}
%   \Description{Enjoying the baseball game from the third-base
%   seats. Ichiro Suzuki preparing to bat.}
%   \label{fig:teaser}
% \end{teaserfigure}

% \received{20 February 2007}
% \received[revised]{12 March 2009}
% \received[accepted]{5 June 2009}

\maketitle

\section{Introduction}

In most programming languages, if we have numeric variables |x| and |y|
and want to add them, we can do so using a simple expression like
\[ |x + y|. \] But what if one of the numbers might not exist?  For
example, perhaps the number was parsed from user input, which might
not be in the right format.  We can represent the possibly-failing
number using some kind of option type, such as |Maybe| in Haskell, XXX
in other languages.  But now the simple expression |x + y| no longer
typechecks, since |x| is (say) of type |Int|, whereas |y| has the
incompatible type (say) |Maybe Int|.  Of course, we can pattern-match
on $y$, taking an appropriate action in each case.  In Haskell, we
might write this as
\begin{code}
case y of
  Nothing  -> Nothing
  Just n   -> Just (x + n)
\end{code}
but now the fact that we are essentially performing an addition
operation has been obscured by a lot of syntax.  If both |x| and |y|
might be undefined, the situation is even worse.

In the Haskell community, \term{applicative functors}, first
introduced by McBride and Paterson XXX cite, are a well-known solution
to this problem.  An applicative functor is any type constructor |A|
which supports operations |pure| and |ap| having the following
polymorphic types (together with some appropriate laws):
\begin{gather*}
|pure : forall t. t -> A t| \\
|ap : A (s -> t) -> (A s -> A t)|
\end{gather*}
That is, |pure| gives us a way to inject plain values of any type |t|
into the type |A t|, and |ap| allows us to distribute |A| over arrows.

For convenience, define |(<*>) = ap|, and
\begin{code}
(<$>) :: (a -> b) -> (A a -> A b)
f <$> x = pure f <*> x
\end{code}
Since |Maybe| is an applicative functor (with |pure = Just| and |ap|
left as an exercise for the reader), if |x, y :: Maybe Int| we can
add them like so:
\[
|(+) <$> x <*> y :: Maybe Int|.
\]
This is certainly much better than writing out nested |case|
statements; it is relatively short and makes it more obvious that we
are doing an addition operation, modulo some details about handling
potential failure.

But it's not good enough!  The |<$>| and |<*>| still introduce
syntactic noise.  XXX Haskell experts are OK with this but

XXX not arguing Haskell should be extended; good reasons Haskell can't
handle this.  DSLs are where the idea really shines\dots

\section{Applicative inference for DSLs}

Examples of DSLs that really benefit from applicative inference.

\begin{itemize}
\item Swarm world DSL
\item \dots
\end{itemize}

\section{Applicative inference by example}

XXX Some examples showing how to do inference

XXX Examples showing that it doesn't matter how we insert coercions

XXX Examples showing that we can't infer monads.

\section{Subtyping for applicative inference}

We begin with a simple collection of types, shown in \pref{fig:types},
consisting of an arbitrary collection of base types, function types,
and box types.  For now, we do not include any other type formers such
as sum or product types; boxes and arrows are enough trouble on their
own!  We will return to consider adding sum and product types in
section XXX.
\begin{figure}[htp]
  \centering
  \ottgrammartabular{\otttype\ottafterlastrule}
  \caption{Types}
  \label{fig:types}
\end{figure}

XXX since we want to be able to implicitly XXX, natural to consider
encoding this via a subtyping relation, defined in
\pref{fig:subtyping}.  The first four rules are fairly standard: the
subtyping relation is reflexive and transitive, has the usual
contravariant/covariant rule for function arrows, and is a congruence
with respect to box (any applicative functor must in fact be a
(covariant) functor, so such a congruence rule always makes sense).
The last two rules are more interesting, and simply reflect the fact
that we want to be able to implicitly insert |pure| and |ap| as
needed.  Thus, we consider any type |t| a subtype of |A t|
(corresponding to an implicit call to |pure|), and similarly we
consider |A (s -> t)| a subtype of |(A s -> A t)| (corresponding to
an implicit |ap|).
\begin{figure}[htp]
  \centering
  \ottdefnsub{}
  \caption{Subtyping}
  \label{fig:subtyping}
\end{figure}
As an example, XXX use example from a previous section, but recast it
in more formal notation.

XXX now introduce terms with standard type system.

Given a term which typechecks in system with subtyping, show that we can
automatically insert coercions, i.e. translate it into term that
typechecks in system with no subtyping but two extra constants for
|pure| and |ap|.

\section{Inversion lemmas / structure}

Looking at the subtyping rules, it is intuitively clear that all the
rules preserve the ``shape'': base types can only be subtypes of other
base types (possibly with boxes on top); a type with an arrow will
always be a subtype of other types with arrows; and so on.  To
formalize this intuition, let |erase(t)| denote the \emph{box erasure}
of |t|, which simply removes all the boxes (XXX put this in a figure):
\begin{gather*}
  |erase(B) = B| \\
  |erase(s -> t) = erase(s) -> erase(t)| \\
  |erase(A t) = erase(t)|
\end{gather*}
Then we can easily prove the following lemma:

\begin{lem}
  If |s <: t| then |s| and |t| have the same underlying shape, that
  is, |erase(s) = erase(t)|.
\end{lem}

\begin{proof}
  Easy proof by induction on subtyping derivations.
\end{proof}

XXX try to prove some inversion lemmas.

\begin{lem}[Left pure]
  If |A s <: t|, then |s <: t|.
\end{lem}

\begin{proof}
  XXX Use transitivity with |pure|.
\end{proof}

\begin{lem}[Box inversion]
  If |A s <: A t|, then |s <: t|.
\end{lem}

This turns out to be true, but it is very difficult to prove directly!
The definition of subtyping in \pref{fig:subtyping} has the advantage
of being simple and obvious: it is nothing more than the reflexive,
transitive closure of the relation which includes axioms for our
desired implicit coercions and is a congruence on boxes and arrows.
However, the transitivity rule is extremely non-syntax-directed and
makes subtyping difficult to reason about: at every step we must take
into account or rule out the possibility of inserting extra steps via
transitivity.  XXX corresponds to a ``cut rule'' in some sort of modal
logic.

\section{Cut-free subtyping}

We therefore present an alternative, ``cut-free'' version of the
subtyping relation, shown in \pref{fig:tf-subtyping}.  The
rules for reflexivity and congruence are the same, whereas the rules
for |pure| and |ap| have been modified to ``bake in'' transitivity.
Note that the only axiom in this system is reflexivity.  Curiously, we
need two variants of the rule for |ap|; the second represents a
combination of |pure| and |ap|, where we first use |pure| to show |s
<< A s|, then use |ap| to push the box down through an arrow.  It is
possible that there is a simpler variant of this system with only a
single rule for |ap|, but this is the only way I was able to make the
proof go through!  XXX could have PureL rule, then rebuild PUREAP as
PureL + AP, but PureL rule was very difficult to work with.

\begin{figure}[htp]
  \centering
  \ottdefnsubt{}
  \caption{Cut-free subtyping}
  \label{fig:tf-subtyping}
\end{figure}

\begin{lem}[Cut elimination]
  For all types |s| and |t|, |s << t| if and only if |s <: t|.
\end{lem}

\begin{proof}
  The forward direction (|s << t| implies |s <: t|) is
  straightforward.  Proving the other direction is nontrivial, and
  relies on several nested inductions.  However, the proof (formally
  checked in Agda) constitutes an algorithm for converting any proof
  of |s <: t| into a cut-free proof of |s << t|.
\end{proof}

Note SUBTPure represents composing on the right with |pure|.  An
earlier version of the system also had PUREL, composing on left with
|pure| (show rule).  However, it created lots of problems.

XXX use to derive more inversion lemmas.

XXX first lemma says that whenever we have a box on the right but no
boxes on the left, we can get rid of the box; i.e. any proof of this
can be rewritten to use PURE as the final rule.

The SUBBOX rule can also be inverted: it says that if |s <: t| then
|A s <: A t|, but the opposite is also true: whenever |A s <: A t|,
then we must have |s <: t|.  In other words, any proof of |A s <: A t|
can be rewritten to use SUBBOX as its final rule.

Proof: more difficult.  Uses PureL, other inversion lemma.

\section{Box trees}

In this section, we develop another model of subtyping.

XXX we know if |s <: t| then they have the same shape.

\begin{thm}[Subtyping is decidable]
  For any types |s| and |t|, we can effectively decide whether |s <: t|.
\end{thm}




% The ``\verb|figure|'' environment should be used for figures. One or
% more images can be placed within a figure. If your figure contains
% third-party material, you must clearly identify it as such, as shown
% in the example below.
% \begin{figure}[h]
%   \centering
%   \includegraphics[width=\linewidth]{sample-franklin}
%   \caption{1907 Franklin Model D roadster. Photograph by Harris \&
%     Ewing, Inc. [Public domain], via Wikimedia
%     Commons. (\url{https://goo.gl/VLCRBB}).}
%   \Description{A woman and a girl in white dresses sit in an open car.}
% \end{figure}

\section{Future work}

Selective functors

Incorporate product and sum types:

\begin{itemize}
\item Product types:
  \begin{itemize}
  \item |unzip : A (a * b) -> A a * A b| can be defined using
    only |Functor|
  \item |zip : A a * A b -> A (a * b)| can be defined using
    |Applicative|
  \item Allow boxes to be pushed through pair types either way?
    Corresponds to a new kind of binary tree node which preserves
    polarity on both branches, and can distribute or collect boxes in
    either direction.
  \end{itemize}
\item Sum types:
  \begin{itemize}
  \item |A a + A b -> A (a + b)| can be defined using only |Functor|
  \item |A (a + b) -> A a + A b| cannot be defined, and would break
    everything! e.g. imagine |A = IO|.  Then this would say given an
    |IO| action that returns |a + b|, we can decide up front (without
    running it!) whether it is going to return |Left| or |Right|.
  \item Would correspond to a new binary tree node which preserves
    polarity, and only allows pulling boxes up at positive nodes, and
    pushing down at negative nodes.
  \end{itemize}
\item Why are product and sum types so different?  Products are
  special because they are adjoint to arrows.
\end{itemize}

\begin{acks}
Acknowledgements.
\end{acks}

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{references}

\appendix

\section{Proofs}

\end{document}
\endinput
%%
%% End of file `sample-sigplan.tex'.
